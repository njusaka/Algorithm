# 题目
### 0.计算矩形相交面积
用x,y,w,h表示坐标系中的一个矩形，其中(x,y)为矩形左上角点的坐标，w和h分别表示矩形的宽和高，
输入时用分号分割的多个矩形参数，输出这多个矩形的公共相交矩形及其面积，若输入的多个矩形不相交，
则输出Error。
###### 输入输出示例
1,2,2,1;2,4,1,3;1,2,2,2

[2,2,1,1]  1
###### 说明
+ 不考虑非法输入的情况
+ 若只有一个矩形，则它本身就是相交矩形 
+ 纵横坐标运算
+ 给定N个矩形求相交矩形，是这么求的，先看左边线，N个矩阵所有左边线集合中的最右边那个，就是相交矩形的左边线 
+ 两个矩形相切的情形，面积为0时也输出 Error 

### 1.循环数组
输入一个数组，将数组中每个成员都向右边移动m次，输出移动后的数组：

例如输入数组为[1 2 3 4 5]，移动次数为2

第一次：[5 1 2 3 4] 

第二次：[4 5 1 2 3] 

输出为[4 5 1 2 3] 

第一行输入数组的大小n，n为一个非负整数，大小不超过100 

第二行输入n个整数，表示数组中的元素 

第三行输入数组成员移动的次数m，m为一个非负整数 

第一行输入数组的大小n，n为一个非负整数，大小不超过100 

第二行输入n个整数，表示数组中的元素 

第三行输入数组成员移动的次数m，m为一个非负整数
###### 输入输出示例
5
1 2 3 4 5

2
4 5 1 2 3 

###### 说明
+ 将数组中每个成员向右移动1位，循环m次； 
+ 数组成员向右移动时需要注意，a[0]的元素要使用a[n - 1]的元素代替 
+ 如果移动的次数m>n，实际与移动m%n次是一样的 

### 2.二叉排序树
使用二叉树对一系列整数排序，并进行前序，中序，后序遍历。 
输入第一行包括一个整数n(1<=n<=100)。接下来的一行包括n个整数。

可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。
###### 输入输出示例
1

2 

2

8 15 

4

21 10 5 39
 
2 

2 

2 

8 15

8 15 

15 8 

21 10 5 39 

5 10 21 39

5 10 39 21 

构造二叉树对输入数据进行存储，按各种遍历方式输出即可。 


### 3.二叉树遍历1
根据输入的一串先序遍历字符串，建立一个二叉树（内存需要动态申请）。再对此二叉树进行中序遍历，输出遍历结果。
例如，输入以下先序遍历字符串：

ABC##DE#G##F###

其中“#”表示的是空格，空格字符代表空树。

每次输入1行字符串，长度不超过100。

可能有多组测试数据，对于每组数据，
输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。
每个输出结果占一行。 
###### 输入输出示例
a#b#cdef#####

a##
 
a b f e d c 

a 

### 4.锐数与捷数
二进制由0或者1构成，如1001，1111等。我们将二进制中1的个数多余0的个数的数称为锐数，其余数均称为捷数。

例如： 
+    二进制的1111，它有4个1,0个0，它为锐数 
+    二进制的1110000，它有3个1,4个0，它为捷数 
+    二进制的1100，它有2个1,2个0，它为捷数 

要求： 
+ 找出1到1000中锐数的个数、与捷数的个数 
+ 1到1000为十进制
###### 输出
+ 在一行输出两个整数num1与num2 
+ 其中num1表示锐数的个数 
+ num2表示捷数的个数 
+ num1与num2用一个空格隔开 
+ 除上述要求之外不要输出任何其他东西 

### 5.栈
1、对于一组包含n个数字的序列，从1，2，一直到n（上图对应序列1,2,3），栈A的元素个数足够容纳序列中的所有元素。 

2、可能的处理有： 栈的push操作（将位于操作数序列头部的数据移到栈的头部）和 栈的pop操作（将位于栈头部的数据移到输出序列的尾部），
使用这两种操作，由一个操作数序列就可以得到一系列的输出序列； 
![pic](https://github.com/njusaka/Algorithm/blob/master/VL/pimg1120_2.jpg)   
示例：其中一个可能的目标序列生成过程如下图所示，原始序列为1,2,3（如上图所示），目标序列为2,3,1
     
3、求由包含n个数字的操作数序列1，2，...，n 经过相关栈操作可能得到的输出序列的总数。
 
输入只含一个整数n（1≤n≤18）。
输出只有一行，即可能输出序列的总数目。 
###### 输入输出示例
3

5
###### 说明
首先，我们设f(n)=序列个数为n的出栈序列种数。(我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式。


f(n)= f(0)*f(n-1)+f(1)*f(n-2) + ... + f(n-1)f(0) (n>=2)

递归函数为:

f(n)=f(n-1)*(4*n-2)/(n+1);


### 6.算式
算式包含字符： “(”、“)”、“0-9”、“+”、“-”、“*”、“/”、“^”。（“/”用整数除法，算式长度<=50，其中所有数据在2^31-1的范围内） 
###### 输入输出示例
1+(3+2)*(7^2+6*9)/(2)

258

### 7.GAME
Ms.Han was addicted to games about light .   
There are N lights putting in a line S[1...N] and we can change their status (open and closed ) by pressing their button. But they have a characteristic, when you press light s[i] (0<=i<=N), those lights who's numbers are i's multiple will also change their status.For example:There are 10 lights s[1...10] whose initial status is closed. When she press the light s[2] (it will be open), then the light s[2],s[4],s[6],s[8] and s[10] will also be open. When she press s[4] again, light s[4] and s[8] will be closed.Now Ms.Han has N lights all closed ,she will press them from 1 to N ,then how many lights will be open in the end?

The input will contain multiple test cases ,Each case will only contain a number N(1 <= N <= 1,000,00).

A integer on a single line for each case indicates the number of lights which are open in the end. 
###### 输入输出示例
10

15

20
 
3

3

4

###### 说明
题目的输入数据行数不限，每组测试用例以文件的形式保存数据，所以可以根据是否读取到文件末尾来判断一组测试用例是否执行完毕。参考代码：while (scanf("%d",&n)!=EOF) {} 
